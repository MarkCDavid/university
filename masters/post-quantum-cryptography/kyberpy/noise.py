from typing import List
from bitarray import BitArray
from Crypto.Hash import SHAKE256
from parameters import PARAMETERS
from utility import to_unsigned_byte

# The noise polynomial (a polynomial with small values) is calculated
# by generating some noise vector, adding `eta` number of bits and 
# subtracting another `eta` bits from the generated noise.
#
# `eta` limits the size of the polynomial coefficients.
def generate_noise_polynomial(seed, nonce):
    noise = get_noise(seed, nonce)
    return [
        sum_consecutive_bits_by_signs(BitArray.fromBytes(noise), offset, get_signs()) 
        for offset 
        in get_offsets()
    ]

# Seed is constructed by taking the original seed and appending
# the given nonce to the end. All value in the seed are converted
# to unsigned bytes.
def construct_seed(seed, nonce) -> 'bytearray':
    return bytearray(
        to_unsigned_byte(byte) 
        for byte 
        in [*seed, nonce]
    )

# Noise is generated by use of SHAKE256. It is seeded with the
# constructed seed, and we take required count of bytes, to be
# able to fully supply noise polynomial coefficient calculations.
# All noise bytes are converted to unsigned bytes.
def get_noise(seed, nonce) -> 'bytes':
    return bytes(
        to_unsigned_byte(byte) 
        for byte in 
        SHAKE256.new(construct_seed(seed, nonce)).read(get_noise_length())
    )

# Calculates the number of bytes required, to perform the calculation
# for noise polynomial coefficient calculation.
# A byte is 8 bits. We need to calculate `n` coefficients. One coefficient
# requires `2 * eta` bits to be calculated. As such, we have:
# `2 * eta * n bits = (2 * eta * n) / 8 bytes = (eta * n) / 4 bytes`
def get_noise_length() -> 'int':
    return (PARAMETERS.eta * PARAMETERS.n) // 4

# When sampling a coefficient for a noise polynomial, the calculation is 
# adding first n/2 and subtracting the next n/2 censecutive bits from the
# pseudo-random noise generator function. Meaning, if we had 001101 with 
# eta = 3, the polynomial coefficient for that index would be calculated 
# as 1 + 0 + 1 - 1 - 0 - 0;
#
# Expanding the example into Python 'bits' of the bit array would have
# values [1, 0, 1, 1, 0, 0] and 'signs' would have values [1, 1, 1, -1, -1, -1].
# This way, the first 3 bits are added, and the next 3 bits are subtracted.
def sum_consecutive_bits_by_signs(bits: 'BitArray', offset: 'int', signs: 'List[int]') -> 'int':
    return sum(
        bits[offset + index] * sign 
        for index, sign
        in enumerate(signs)
    )

# Creates a list of offsets for coefficient calculations. During sum by
# signs calculation, we add first 'eta' bits, and then subtract the next
# 'eta' bits. As such, in total we must offset our sampling from the
# pseudo-random noise generator function by '2 * eta' for every coefficient.
def get_offsets() -> 'List[int]':
    return [
        2 * PARAMETERS.eta * i 
        for i 
        in range(0, PARAMETERS.polynomial_coefficient_count)
    ]

# Creates a list of signs for coefficient calculations. The first
# 'eta' signs will be positive, the next 'eta' signs will be negative.
# e.g:
# eta = 1 => [1, -1]
# eta = 4 => [1, 1, 1, 1, -1, -1, -1, -1]
def get_signs() -> 'List[int]':
    return [
        *([ 1] * PARAMETERS.eta), 
        *([-1] * PARAMETERS.eta)
    ]