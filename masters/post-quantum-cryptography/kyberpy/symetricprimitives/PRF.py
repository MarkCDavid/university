from typing import List
from Crypto.Hash import SHAKE256
from parameters import PARAMETERS
from utility import to_unsigned_byte

# REFERENCE: CRYSTALS-Kyber, Symmetric primitives, p. 5
# URL: https://pq-crystals.org/kyber/data/kyber-specification-round3-20210804.pdf

# Pseudo Random Function (PRF)
# input: bytearray, byte
# output: bytearray

# Noise is generated by use of SHAKE256. It is seeded with the
# constructed seed, and we take required count of bytes, to be
# able to fully supply noise polynomial coefficient calculations.
# All noise bytes are converted to unsigned bytes.

# We need to pass `eta` along, to ensure we're generating enough bytes.
def PRF(eta: 'int', seed: "List[int]", nonce: "int") -> "bytes":
    return bytes(to_unsigned_byte(byte) for byte in SHAKE256.new(construct_seed(seed, nonce)).read(get_noise_length(eta)))


# Seed is constructed by taking the original seed and appending
# the given nonce to the end. All value in the seed are converted
# to unsigned bytes.
def construct_seed(seed, nonce) -> "bytearray":
    return bytearray(to_unsigned_byte(byte) for byte in [*seed, nonce])

# Calculates the number of bytes required, to perform the calculation
# for noise polynomial coefficient calculation.
# A byte is 8 bits. We need to calculate `n` coefficients. One coefficient
# requires `2 * eta` bits to be calculated. As such, we have:
# `2 * eta * n bits = (2 * eta * n) / 8 bytes = (eta * n) / 4 bytes`
def get_noise_length(eta: 'int') -> "int":
    return (eta * PARAMETERS.n) // 4
